---
title: "Gender-Pkg-NV-Salary"
author: "Maria Guidengg"
output: rmarkdown::github_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Application of Gender R package for my learning

**About**

[Gender](https://CRAN.R-project.org/package=gender) is an R package that predicts the gender of a name based on historical data. I'll explore this package as well as apply it to salary data provided by [NPRI](www.transparentnevada.com) on Nevada public employees.

The input and output files are located in the `data` folder. In its original form, the input file _all-nevada-2016.csv_ is obtained from a [separate repository](https://github.com/mguideng/Nevada-Public-Salaries) and has 12 columns. The output file _all-nevada-2016-with-gender.csv_ is the same, but has an additional column for employee gender. My contribution is the R script that adds this feature through the use of this package.

## Exploring what's in the gender package
```{r warning=F, comment=T, message=F}
#install.packages("gender")
library(gender)
ls("package:gender")
#help(package = "gender")
```

After referencing the package's documentation and vignettes, I see that the basic function is `gender()`. One of its cool features is that it accounts for the fact that genders associated with names can change over time. Also, loading this package prompts you to install the `genderdata` package, which contains several datasets that permits the user to make predictions based on different time periods and  geographical regions. As such, `gender()` allows you to choose a method to pass a set of names, places and birth years through the function.

Taken directly from the documentation, the basic usage is:

```
gender(names, years = c(1932, 2012), method = c("ssa", "ipums", "napp","kantrowitz", "genderize", 
"demo"),countries = c("United States", "Canada","United Kingdom", "Germany", "Iceland", "Norway", 
"Sweden"))
```

...where `method` provides six options:
* **ssa**: United States from 1930 to 2012. Drawn from Social Security Administration data. Option to select by state.
* **ipums**: United States from 1789 to 1930. Drawn from Census data.
* **napp**: Canada, the United Kingdom, Germany, Iceland, Norway, and Sweden for years between 1758 and 1910.
* **kantrowitz**: 7,579 unique names compiled by Mark Kantrowitz in 1991.
* **genderize**: based on "user profiles across major social networks."
* **demo**: Uses the top 100 names in the ssa method; provided for demonstration purposes (and not suitable for research purposes) when the `genderdata` package is not installed.

...and `countries` is the countries for which datasets are being used. For the:
* "ssa" and "ipums" methods, the only valid option is **United States** which will be assumed if no argument is specified;
* "napp" method, you may specify a character vector with: **Canada**, **United Kingdom**, **Germany**, **Iceland**, **Norway**, and **Sweden**; and
* "kantrowitz" and "genderize" methods, no country should be specified.

If no method or years are specified, `gender()` will default to the ssa method for years 1932 - 2012. We'll keep things simple and go this route since it's the most suitable method for our salary data.

## Bringing in other packages & the data

`stringr` and `dplyr` will help to manipulate the names and summarize tabular data.

```{r warning=F, comment=F, message=F}
#install.packages(c("stringr", "dplyr"))
library(stringr)
library(dplyr)
```

Next, we'll import the input file _all-nevada.2016.csv_. 


```{r}
salary <- read.csv("C:/Users/Rie Guide/Google Drive/NerdyRie/IP - GitHub/Repos/Gender-Pkg-NV-Salary/data/all-nevada-2016.csv")
```

Let's check it out!

```{r, eval=TRUE}
str(salary)
```

```{r, eval=TRUE}
head(salary,5)
```

There's a total of 146,662 employees. We're only interested in using the `Employee.Name` variable here. Since the names are combined, we'll need to parse out the vector of character strings. 

## Preparing the salary data
Before passing the data through the gender function, it has to be prepped. The historical data of names within the package doesn't have any non-character symbols (e.g., digits, periods, hyphens, whitespace). It also uses lower title cases. Then we'll isolate the first names. The expected naming order convention is that the first name will be followed by the the middle and last names ("maria guideng"). It's also common to report the first name following a comma ("guideng, maria"). Our data should mimic these features. So those are three tasks so far. 

```{r}
# Task 1. Remove non-characters. The order these are run is important.

salary$Employee.Name <- str_replace_all(salary$Employee.Name, "\\d |\\d", "")  # Remove digits.
salary$Employee.Name <- gsub("\\.", " ", salary$Employee.Name)                 # Replace periods with a space.
salary$Employee.Name <- gsub("-", " ", salary$Employee.Name)                   # Replace hypens with a space.
salary$Employee.Name <- gsub("   ", " ", salary$Employee.Name)                 # Remove triple spaces.
salary$Employee.Name <- gsub("  ", " ", salary$Employee.Name)                  # Remove double spaces.

# Task 2. Isolate first names. If a comma is present in `Employee.Name` ("guideng, maria"), the first element of the string will be taken as `First.Name`. Otherwise ("maria guideng"), the first element of the string will be taken.

salary$First.Name <- sub(".*\\, ", "", salary$Employee.Name)  # If comma, take element following comma.
salary$First.Name <- sub(" .*", "", salary$First.Name)        # Otherwise, just take first element.


# Task 3. Lower case the first names.
salary$First.Name <- str_to_lower(salary$First.Name)
```

## Ready for the gender function

Alas, let's run the gender function on the newly-created `First.Name` column.
```{r}
salary_gender <- gender(salary$First.Name)
```

It inferred the gender of 93% of the total employees (136,306 of 146,662 total). That's pretty good! Let's take a peek.
```{r}
head(salary_gender,5)
```

The gender function took a character vector of names and a range of years to predict the gender. Here, "aalya" has been proportionately all female, while "aamir" has undoubtedly been a male name. It's not so clear for the name "aarin" however, which has historically been nearly half and half: 56.4% being males and 43.6% females. However, it favors a male gender and is assigned as such.

We will join this to the main salary dataframe, so let's clean it up. Keep just the "name" and "gender" variables and rename them so they match the salary header names. Removing the duplicate names will also help make joining easier.
```{r}
salary_gender <- salary_gender[c("name", "gender")]
colnames(salary_gender) <- c("First.Name", "Gender")
salary_gender <- subset(salary_gender, !duplicated(salary_gender$First.Name))
```
Join it to the salary dataframe by `First.Name`.
```{r}
salary <- left_join(salary, salary_gender)
```

What's the distribution of males and females employees?
```{r}
salary %>%
  group_by(Gender) %>%
  summarize(employees=n()) %>%
  mutate(percent=round((employees/sum(employees)*100))) %>%
  arrange(desc(percent))
```

Based on our work so far, women dominate the workforce when it comes to public service in Nevada. It's estimated to be at 53% but it would actually be more since it doesn't capture any of the 7% of workers whose gender is undetermined. Let's set them to "undetm" in our data.
```{r}
salary$Gender[is.na(salary$Gender)] <- "undetm"
```

Take a closer look and see what's going with the undetermined gender names by checking for patterns in the names and agencies. Can we do a better job?
```{r}
undetm <- salary %>%
  filter(Gender=="undetm") %>%
  group_by(First.Name, Employee.Name, Agency) %>%
  summarize (n = n()) %>%
  arrange(-n)

print(undetm)
```


Which agencies have employees with the most undetermined genders?
```{r}
undetm %>%
  group_by(Agency) %>%
  summarize (n = n()) %>%
  arrange(-n)
```

## Fixing undetermined genders

After some poking around, here are the issues identified:

1. First thing I noticed is that there's some names that are redacted or classified as being undercover. In these cases, keep them as is. Also, as expected, the package fails to make predictions for quite a bit of ethnic names, particularly for employees bearning names of Asian descent. We could look for a solution later, but we'll leave them as is for now.
    
2. Another issue is that University Medical Center reports employees using a different naming convention where last name is reported first without a comma preface ("guideng maria"). Clark County also does at times, but much less often than not. And while Clark County has the highest number of ambiguous names by count, it's also one of the largest agencies in that state with nearly 14,000 employees.
    
3. First names sometimes appear as suffixes ("sr", "iii", "iv") such as for these folks:
     * "sr timothy a maleport sr"
     * "iii carl william hart"
     * "iv joseph m schum"
    
4. Also, there's numerous instances where the first and last elements of `Employee.Name` are the same.  For example,:
      * "abarca daniel gonzalez abarca"
      * "kirgan marsha matsunaga kirgan"
      * "suarez juan r calvillo suarez"
    
5. Lastly, single-initial letters are being picked up as first names and that defies inferring a gender. E.g.,:
      * "a elaine renta"
      * "m shane leavitt"
      * "p d ingram"

Fortunately, the wrangling to fix issues 2 - 5 won't be so bad. It would be reasonable to adopt the second string of characters in `Employee.Name` as the first name in these cases, don't you think? It won't resolve them all, like for Mr.? or Ms.? P D Ingram, but it will help.

Ok, let's do it! First, some basic string split operations for later pattern matching functions. 
```{r}
salary$stringcount <- str_count(salary$Employee.Name," ")+1                      # Count of all elements in string.
salary$string1 <- sapply(strsplit(salary$Employee.Name, " "), function(x) x[1])  # 1st string only.
salary$string1len <- nchar(salary$string1)                                       # Length of 1st string.
salary$string2 <- sapply(strsplit(salary$Employee.Name, " "), function(x) x[2])  # 2nd string.
salary$stringN <- sapply(strsplit(salary$Employee.Name, " "), tail, 1)           # Last string.

# Fix issue 2. UMC reports last names first
salary$First.Name <- ifelse(salary$Agency %in% c("University Medical Center"), salary$string2, salary$First.Name)

# Fix issue 3. Suffix
salary$First.Name <- ifelse(salary$First.Name %in% c("jr","sr", "ii", "iii", "iv"), salary$string2, salary$First.Name)

# Fix issue 4. First string = Last string
salary$First.Name <- ifelse(salary$string1 == salary$stringN & salary$stringcount>1, salary$string2, salary$First.Name)

# Fix issue 5. Initials. These are identified as those with `First.Name` having a length of 1 (basically, an initial) AND a count of 3+ elements in `Employee.Name`.
salary$First.Name <- ifelse(salary$string1len == 1 & salary$stringcount>=3, salary$string2, salary$First.Name)
```

## Gender function, Round 2
Ready to rerun that gender function on this updated salary dataframe.
```{r}
salary_gender <- gender(salary$First.Name)

# Again, just keep the "name" and "gender" variables and rename them, as well as remove the dupes.
salary_gender <- salary_gender[c("name", "gender")]
colnames(salary_gender) <- c("First.Name", "Gender")
salary_gender <- subset(salary_gender, !duplicated(salary_gender$First.Name))

# Now we can re-join it to the salary dataframe by `First.Name`, but first remove `Gender` from the previous run.
salary$Gender <- NULL
salary <- left_join(salary, salary_gender)
salary$Gender[is.na(salary$Gender)] <- "undetm"
```

Any better from that unknown 7%?
```{r}
table(salary$Gender)
prop.table(table(salary$Gender))
```

Yes, that's a bit better! Applying these fixes matched gender for another ~2,500 employees to 138,839 total employees. It's now down to 5% overall. How about on the agency level?

```{r}
undetm <- salary %>%
  filter(Gender=="undetm") %>%
  group_by(First.Name, Employee.Name, Agency) %>%
  summarize (n = n()) %>%
  arrange(-n)

undetm %>%
  group_by(Agency) %>%
  summarize (n = n()) %>%
  arrange(-n)
```


There's improvements pretty much across the board for all agencies, especially with UMC.

Ok, so our last step is to revert back to the original structure of 12 columns, plus another column for `Gender`.
```{r}
names(salary)
```


```{r}
salary <- salary[, -c(13:18)]   # delete columns 13 through 18
```

## Output 
Success. It's now ready for export.

```{r}
write.csv(salary, "all-Nevada-2016-with-gender.csv")
```

**Output dimensions**

| File                | Total Rows | Total Columns | Columns                                                                                                                                  |
|---------------------|------------|---------------|------------------------------------------------------------------------------------------------------------------------------------------|
| all-Nevada-2016-with-gender.csv | 146,662     | 13            | Employee.Name, Job.Title, Base.Pay, Overtime.Pay, Other.Pay, Benefits, Total.Pay, Total.PayBenefits, Year, Notes, Agency, Status, Gender |

**Exploration ideas**
  * How many women work in government versus men and for which agencies?
  * How is pay different between men and women by job titles?

**Project purposes**
  * Adding a gender column using Gender, an R package.
  * Being new to R, suggestions for improvement are appreciated.